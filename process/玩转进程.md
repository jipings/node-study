
## 玩转进程

单线程，状态单一，没有多线程的情况下没有线程锁，线程同步问题，操作系统在调度时也因为较少的上下文的切换，可以很好的提高CPU的使用率。

### 如何充分利用多核CPU服务器？

Node 执行在单线程上，一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃。

### 如何保证进程的健壮性和稳定性？

### Master-Worker

主进程和工作进程，这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向稳定的。工作进程负责具体的业务处理，因为业务的多样性，所以工作进程的稳定性值得开发者关注。

通过fork() 复制的进程都是一个独立的进程，这个进程中有着独立而全新额V8实例。它需要至少30ms的启动时间和至少10mb的内存。尽管Node提供了fork()供我们复制进程使每个cpu内核都使用上，但是依然要切记fork()进程是昂贵的。Node通过事件驱动方式在单线程上解决了大并发的问题

### 如何创建子进程
child_process 模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法

* spawn() : 启动一个子进程来执行命令
* exec() ：启动一个子进程来执行命令，与spawn() 不同的是其接口不同，它有一个回调函数获取子进程的状态。
* execFile() : 启动一个子进程来执行可执行文件
* fork(): 与 spawn() 类似，不同点在于它创建Node的子进程只需要执行的JavaScript文件模块即可。

### 进程间通信

主线程与工作线程之间的通信通过onmessage() 和 postMessage() 进行通信，子进程对象则由send() 方法实现主进程向子进程发送数据，message 事件实现收听子进程发来的数据，与API在一定程度上相似。通过消息传递内容，而不是共享或者直接操作相关资源，这是较为轻量和无依赖的做法。

### 进程间通信原理
* IPC的全称是 `Inter-Process Communication`, 即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实际进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket。
Node中实现IPC通道的是管道（pipe）技术。
* 句柄传递  句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象，一个客户端socket对象、一个UDP套接字。

### 句柄发送和还原

* net.Socket TCP 套接字
* net.Server TCP 服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处
* net.Native C++ 层面的UDP套接字
* dgram.Socket UDP 套接字
* dgram.Native C++ 层面的UDP 套接字

### 集群稳定
集群问题
* 性能问题
* 多个工作进程的平滑重启
* 配置或者静态数据的动态重新载入
* 稳定性，虽然我们创建了很多工作进程，但每个工作进程依然是单线程上执行的，它的稳定性还不能得到完全的保障。我们需要建立起以一个健全的机制来保障Node应用的健壮性。

### 进程事件
进程除了send() 和 message 事件还有什么？
* error: 当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件
* exit: 子进程退出时触发该事件，子进程如果正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill() 方法杀死的，会得到第二个参数，它表示杀死进程时的信号。
* close: 在子进程的标准输入输出流中止时触发该事件，参数与exit 相同
* disconnect: 在父进程或子进程中调用disconnnect() 方法时触发该事件，在调用该方法时将关闭监听IPC通道

### 自动重启


### 状态共享
* 第三方存储
* 主动通知： 当数据发生变更时，主动通知子进程。当然，即使主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。为了不混合业务逻辑，可以将这个进程设计为只进行轮询和通知，不处理任何业务逻辑。

这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程。由于不涉及太多进程去向同一地方进行状态查询，状态响应处的压力不至于太过巨大，单一的通知服务轮询带来的压力并不大，所以可以将轮询时间调整得较短，一旦发现更新，就能实时地推送到各个子进程中。

### Cluster 模块
对于健壮性处理，cluster模块也暴露了相当多的事件
* fork: 复制一个工作进程后触发该事件
* online: 复制好一个工作进程后，工作进程主动发送一条 online 消息给主进程，主进程收到消息，触发该事件。
* disconnect: 主进程和工作进程之间IPC通道断开后会触发该事件
* exit: 有工作进程退出时触发该事件
* setup: cluster.setupMaster() 执行后触发事件
